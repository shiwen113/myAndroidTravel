1、线程的同步：多个线程使用同一个对象，锁
    synchronized(object){//同步块}   //1.4
    Lock lock = new ReentrantLock(); //1.5
    try {
      lock.lock();
      //同步块
    }finally{
    	lock.unlock();
    }
  线程安全对象：多个线程使用同一个对象是安全
    最安全的解决方法：类的所有方法都加synchronized

2、线程间的通信
   生产者-消费者模型(难)：
      存 - 取  - 存  - 取 。。。。。。。（次序不乱）
   
   class  C {
       标志位：说明谁先开始
      方法: 同步：存 ｛
         如果没有轮到我，等
         如果轮到我，完成功能，通知其它线程
      ｝   
      方法：取
   }
   再写两个线程:分别调用上面对象上的两个方法
      obj.wait():  Thread.currentThread线程 在obj对象上等
                   等的时候，释放锁
                   只能在同步块中使用
      obj.notifyAll(): 唤醒在obj对象等待的线程
   实现的两种方法：
     1）传统：synchronized  obj.wait  obj.notifyALl
     2) 1.5： Lock  Condition (await  signalAll)

3、线程池(了解)
   Excutors(实用工具类)：静态方法，获得各种不同类型的线程池
   ExecutorService：
  线程框架Excutor：
     new Thread(new Runnable(){}).start();
   1）new Runnable(){}, new Callable() {}  线程要执行的任务
        run()               call();（有返回值）        
   2) 执行任务

  接口及类:

  1.7特性：ForkJoinPool(了解)：大任务===》分解小任务，小任务并发完成

4、ThreadLocal变量：包含了一个值（对象）
   普通类型变量：多个线程共享这个变量
   ThreadLocal变量：每个线程各有一份，相互之间没有关系
    初始化(initialValue)，取值（get），赋值(set)

5、线程安全的集合：ArrayList HashMap HashSet 不是线程安全的
  1）Collections.synchronizedXxx(Xxx集合): 不安全的集合==》安全的
  2) 1.5提供了一些集合类，这些类就是线程安全的
       concurrentXxx   CopyOnWriteXxx
















